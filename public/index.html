<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Clippy Clipboard Sync</title>
    <!-- Roboto font & Material Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <!-- MUI, React, Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@mui/material@5.15.0/umd/material-ui.development.js" crossorigin></script>
    <script src="https://unpkg.com/@emotion/react@11.11.1/dist/emotion-react.umd.min.js" crossorigin></script>
    <script src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      #root {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const {
        Button,
        Container,
        CssBaseline,
        Box,
        Paper,
        Typography,
        Snackbar,
        Alert,
        CircularProgress,
        Icon,
        IconButton,
        Tooltip,
        createTheme,
        ThemeProvider,
      } = MaterialUI;

      // Convert a blob to a base64 data URI
      function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      // Convert a base64 data URI back to a blob
      function dataURLToBlob(dataURL) {
        const [header, base64] = dataURL.split(",");
        const mime = header.match(/:(.*?);/)[1];
        const binary = atob(base64);
        const array = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          array[i] = binary.charCodeAt(i);
        }
        return new Blob([array], { type: mime });
      }

      function App() {
        const [darkMode, setDarkMode] = React.useState(() => {
          return localStorage.getItem("clippy-dark-mode") === "true";
        });
        const [content, setContent] = React.useState("");
        const [type, setType] = React.useState("text");
        const [loading, setLoading] = React.useState(false);
        const [snackbar, setSnackbar] = React.useState({ open: false, message: "", severity: "success" });
        const [fetching, setFetching] = React.useState(true);

        const theme = React.useMemo(() => createTheme({
          palette: { mode: darkMode ? "dark" : "light" },
        }), [darkMode]);

        const toggleDarkMode = () => {
          setDarkMode(prev => {
            const next = !prev;
            localStorage.setItem("clippy-dark-mode", String(next));
            return next;
          });
        };

        // Copy button handler
        const handleCopy = async () => {
          try {
            if (type === "image") {
              const blob = dataURLToBlob(content);
              await navigator.clipboard.write([
                new ClipboardItem({ [blob.type]: blob }),
              ]);
            } else {
              await navigator.clipboard.writeText(content);
            }
            setSnackbar({ open: true, message: "Copied to clipboard!", severity: "success" });
          } catch (e) {
            setSnackbar({ open: true, message: "Copy failed", severity: "error" });
          }
        };

        // Polling: fetch every 2s
        React.useEffect(() => {
          let active = true;
          const fetchClipboard = () => {
            fetch("/api/clipboard")
              .then(res => res.json())
              .then(data => {
                if (active) {
                  setContent(data.content || "");
                  setType(data.type || "text");
                }
                setFetching(false);
              })
              .catch(() => {
                setSnackbar({ open: true, message: "Failed to fetch clipboard", severity: "error" });
                setFetching(false);
              });
          };
          fetchClipboard();
          const interval = setInterval(fetchClipboard, 2000);
          return () => {
            active = false;
            clearInterval(interval);
          };
        }, []);

        // Paste button handler â€” auto-detects image vs text
        const handlePaste = async () => {
          setLoading(true);
          try {
            const items = await navigator.clipboard.read();
            let pastedContent = "";
            let pastedType = "text";

            for (const item of items) {
              // Check for image types first
              const imageType = item.types.find(t => t.startsWith("image/"));
              if (imageType) {
                const blob = await item.getType(imageType);
                pastedContent = await blobToDataURL(blob);
                pastedType = "image";
                break;
              }
              // Fall back to text
              if (item.types.includes("text/plain")) {
                const blob = await item.getType("text/plain");
                pastedContent = await blob.text();
                pastedType = "text";
                break;
              }
            }

            setContent(pastedContent);
            setType(pastedType);

            const res = await fetch("/api/clipboard", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ content: pastedContent, type: pastedType }),
            });
            if (!res.ok) throw new Error("Server error");
            setSnackbar({ open: true, message: "Clipboard synced!", severity: "success" });
          } catch (e) {
            setSnackbar({ open: true, message: "Clipboard read or sync failed", severity: "error" });
          } finally {
            setLoading(false);
          }
        };

        // Render content based on type
        const renderContent = () => {
          if (fetching) {
            return <Box display="flex" justifyContent="center"><CircularProgress size={32} /></Box>;
          }
          if (!content) {
            return (
              <Typography color="text.secondary" align="center">
                (No clipboard content yet)
              </Typography>
            );
          }
          if (type === "image") {
            return (
              <Box display="flex" justifyContent="center">
                <img
                  src={content}
                  alt="Clipboard image"
                  style={{ maxWidth: "100%", maxHeight: "60vh", objectFit: "contain", borderRadius: 4 }}
                />
              </Box>
            );
          }
          return content;
        };

        return (
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Box sx={{ position: "fixed", top: 16, right: 16 }}>
              <Tooltip title={darkMode ? "Switch to light mode" : "Switch to dark mode"}>
                <IconButton onClick={toggleDarkMode} color="inherit">
                  <Icon>{darkMode ? "light_mode" : "dark_mode"}</Icon>
                </IconButton>
              </Tooltip>
            </Box>
            <Container maxWidth="sm" sx={{ mt: 8 }}>
              <Box display="flex" flexDirection="column" alignItems="center" gap={3}>
                <Button
                  variant="contained"
                  size="large"
                  startIcon={<Icon>content_paste</Icon>}
                  onClick={handlePaste}
                  disabled={loading}
                  sx={{ fontSize: 24, py: 2, px: 4 }}
                >
                  PASTE
                </Button>
                <Box sx={{ position: "relative", width: "100%" }}>
                  <Paper
                    elevation={3}
                    sx={{
                      width: "100%",
                      minHeight: 120,
                      p: 3,
                      bgcolor: "background.paper",
                      whiteSpace: "pre-wrap",
                      wordBreak: "break-word",
                      fontFamily: "'Roboto Mono', monospace",
                      fontSize: 18,
                      position: "relative",
                    }}
                  >
                    <Box sx={{ position: "absolute", top: 8, right: 8, zIndex: 1 }}>
                      <Tooltip title="Copy to clipboard">
                        <span>
                          <Button
                            variant="contained"
                            color="primary"
                            size="small"
                            startIcon={<Icon>content_copy</Icon>}
                            onClick={handleCopy}
                            disabled={!content}
                            aria-label="copy"
                            sx={{ fontSize: 12, py: 1, px: 2 }}
                          >
                            COPY
                          </Button>
                        </span>
                      </Tooltip>
                    </Box>
                    {renderContent()}
                  </Paper>
                </Box>
              </Box>
            </Container>
            <Snackbar
              open={snackbar.open}
              autoHideDuration={3000}
              onClose={() => setSnackbar(s => ({ ...s, open: false }))}
              anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
            >
              <Alert
                onClose={() => setSnackbar(s => ({ ...s, open: false }))}
                severity={snackbar.severity}
                sx={{ width: "100%" }}
              >
                {snackbar.message}
              </Alert>
            </Snackbar>
          </ThemeProvider>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
