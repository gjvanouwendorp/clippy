<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self'">
    <title>Clippy Clipboard Sync</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path d='M15.5 3C13.57 3 12 4.57 12 6.5V17.5C12 18.88 13.12 20 14.5 20C15.88 20 17 18.88 17 17.5V7H15V17.5C15 17.78 14.78 18 14.5 18C14.22 18 14 17.78 14 17.5V6.5C14 5.67 14.67 5 15.5 5C16.33 5 17 5.67 17 6.5V17.5C17 18.88 15.88 20 14.5 20C13.12 20 12 18.88 12 17.5V7H10V17.5C10 19.99 12.01 22 14.5 22C16.99 22 19 19.99 19 17.5V6.5C19 4.57 17.43 3 15.5 3Z' fill='%23666' transform='rotate(180 12 12)'/></svg>">
    <!-- Roboto font & Material Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <!-- MUI, React, Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@mui/material@5.15.0/umd/material-ui.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@emotion/react@11.11.1/dist/emotion-react.umd.min.js" crossorigin></script>
    <script src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      #root {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const {
        Button,
        Container,
        CssBaseline,
        Box,
        Paper,
        Typography,
        Snackbar,
        Alert,
        CircularProgress,
        Icon,
        IconButton,
        Tooltip,
        Switch,
        FormControlLabel,
        createTheme,
        ThemeProvider,
      } = MaterialUI;

      // Convert a blob to a base64 data URI
      function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      // Convert a base64 data URI back to a blob
      function dataURLToBlob(dataURL) {
        const [header, base64] = dataURL.split(",");
        const mime = header.match(/:(.*?);/)[1];
        const binary = atob(base64);
        const array = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          array[i] = binary.charCodeAt(i);
        }
        return new Blob([array], { type: mime });
      }

      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false };
        }
        static getDerivedStateFromError() {
          return { hasError: true };
        }
        render() {
          if (this.state.hasError) {
            return React.createElement(Box, {
              display: "flex", flexDirection: "column", alignItems: "center",
              justifyContent: "center", minHeight: "100vh", gap: 2,
            },
              React.createElement(Icon, { sx: { fontSize: 48, color: "error.main" } }, "error_outline"),
              React.createElement(Typography, { variant: "h6" }, "Something went wrong."),
              React.createElement(Button, {
                variant: "contained", onClick: () => this.setState({ hasError: false }),
              }, "Try again")
            );
          }
          return this.props.children;
        }
      }

      function App() {
        const [darkMode, setDarkMode] = React.useState(() => {
          return localStorage.getItem("clippy-dark-mode") === "true";
        });
        const [autoPaste, setAutoPaste] = React.useState(() => {
          return localStorage.getItem("clippy-auto-paste") === "true";
        });
        const [content, setContent] = React.useState("");
        const [type, setType] = React.useState("text");
        const [loading, setLoading] = React.useState(false);
        const [snackbar, setSnackbar] = React.useState({ open: false, message: "", severity: "success" });
        const [fetching, setFetching] = React.useState(true);
        const [updatedAt, setUpdatedAt] = React.useState(null);
        const [timeAgo, setTimeAgo] = React.useState("");
        const [justCopied, setJustCopied] = React.useState(false);

        const formatTimeAgo = (isoString) => {
          if (!isoString) return "";
          const seconds = Math.floor((Date.now() - new Date(isoString).getTime()) / 1000);
          if (seconds < 5) return "just now";
          if (seconds < 60) return seconds + "s ago";
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + "m ago";
          const hours = Math.floor(minutes / 60);
          return hours + "h ago";
        };

        // Update the relative time string every second
        React.useEffect(() => {
          setTimeAgo(formatTimeAgo(updatedAt));
          const timer = setInterval(() => setTimeAgo(formatTimeAgo(updatedAt)), 1000);
          return () => clearInterval(timer);
        }, [updatedAt]);

        const theme = React.useMemo(() => createTheme({
          palette: { mode: darkMode ? "dark" : "light" },
        }), [darkMode]);

        const toggleDarkMode = () => {
          setDarkMode(prev => {
            const next = !prev;
            localStorage.setItem("clippy-dark-mode", String(next));
            return next;
          });
        };

        const toggleAutoPaste = () => {
          setAutoPaste(prev => {
            const next = !prev;
            localStorage.setItem("clippy-auto-paste", String(next));
            return next;
          });
        };

        // Copy button handler
        const handleCopy = async () => {
          try {
            if (type === "image") {
              const blob = dataURLToBlob(content);
              await navigator.clipboard.write([
                new ClipboardItem({ [blob.type]: blob }),
              ]);
            } else {
              await navigator.clipboard.writeText(content);
            }
            setJustCopied(true);
            setTimeout(() => setJustCopied(false), 1500);
            setSnackbar({ open: true, message: "Copied to clipboard!", severity: "success" });
          } catch (e) {
            setSnackbar({ open: true, message: "Copy failed", severity: "error" });
          }
        };

        // Polling: fetch every 2s
        React.useEffect(() => {
          let active = true;
          const fetchClipboard = () => {
            fetch("/api/clipboard")
              .then(res => res.json())
              .then(data => {
                if (active) {
                  setContent(data.content || "");
                  setType(data.type || "text");
                  setUpdatedAt(data.updatedAt || null);
                }
                setFetching(false);
              })
              .catch(() => {
                setSnackbar({ open: true, message: "Failed to fetch clipboard", severity: "error" });
                setFetching(false);
              });
          };
          fetchClipboard();
          const interval = setInterval(fetchClipboard, 2000);
          return () => {
            active = false;
            clearInterval(interval);
          };
        }, []);

        // Paste button handler â€” auto-detects image vs text
        const handlePaste = async () => {
          setLoading(true);
          try {
            const items = await navigator.clipboard.read();
            let pastedContent = "";
            let pastedType = "text";

            for (const item of items) {
              // Check for image types first
              const imageType = item.types.find(t => t.startsWith("image/"));
              if (imageType) {
                const blob = await item.getType(imageType);
                pastedContent = await blobToDataURL(blob);
                pastedType = "image";
                break;
              }
              // Fall back to text
              if (item.types.includes("text/plain")) {
                const blob = await item.getType("text/plain");
                pastedContent = await blob.text();
                pastedType = "text";
                break;
              }
            }

            setContent(pastedContent);
            setType(pastedType);

            const res = await fetch("/api/clipboard", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ content: pastedContent, type: pastedType }),
            });
            if (!res.ok) throw new Error("Server error");
            setSnackbar({ open: true, message: "Clipboard synced!", severity: "success" });
          } catch (e) {
            setSnackbar({ open: true, message: "Clipboard read or sync failed", severity: "error" });
          } finally {
            setLoading(false);
          }
        };

        // Clear button handler
        const handleClear = async () => {
          try {
            const res = await fetch("/api/clipboard", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ content: "", type: "text" }),
            });
            if (!res.ok) throw new Error("Server error");
            setContent("");
            setType("text");
            setSnackbar({ open: true, message: "Clipboard cleared!", severity: "success" });
          } catch (e) {
            setSnackbar({ open: true, message: "Clear failed", severity: "error" });
          }
        };

        // Auto-paste on window focus
        const handlePasteRef = React.useRef(handlePaste);
        handlePasteRef.current = handlePaste;
        React.useEffect(() => {
          if (!autoPaste) return;
          const onFocus = () => handlePasteRef.current();
          window.addEventListener("focus", onFocus);
          return () => window.removeEventListener("focus", onFocus);
        }, [autoPaste]);

        // Render content based on type
        const renderContent = () => {
          if (fetching) {
            return <Box display="flex" justifyContent="center"><CircularProgress size={32} /></Box>;
          }
          if (!content) {
            return (
              <Typography color="text.secondary" align="center">
                (No clipboard content yet)
              </Typography>
            );
          }
          if (type === "image") {
            return (
              <Box display="flex" justifyContent="center">
                <img
                  src={content}
                  alt="Clipboard image"
                  style={{ maxWidth: "100%", maxHeight: "60vh", objectFit: "contain", borderRadius: 4 }}
                />
              </Box>
            );
          }
          return content;
        };

        return (
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Box sx={{
              position: "fixed", top: 0, left: 0, right: 0, zIndex: 1100,
              display: "flex", flexWrap: "wrap", alignItems: "center",
              justifyContent: "space-between",
              px: 3, py: 1.5,
              bgcolor: "background.default",
              borderBottom: 1, borderColor: "divider",
            }}>
              <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path
                    d="M15.5 3C13.57 3 12 4.57 12 6.5V17.5C12 18.88 13.12 20 14.5 20C15.88 20 17 18.88 17 17.5V7H15V17.5C15 17.78 14.78 18 14.5 18C14.22 18 14 17.78 14 17.5V6.5C14 5.67 14.67 5 15.5 5C16.33 5 17 5.67 17 6.5V17.5C17 18.88 15.88 20 14.5 20C13.12 20 12 18.88 12 17.5V7H10V17.5C10 19.99 12.01 22 14.5 22C16.99 22 19 19.99 19 17.5V6.5C19 4.57 17.43 3 15.5 3Z"
                    fill="currentColor"
                    transform="rotate(180 12 12)"
                  />
                </svg>
                <Typography
                  variant="h5"
                  component="span"
                  sx={{ fontWeight: 700, letterSpacing: 0.5 }}
                >
                  Clippy
                </Typography>
                <Typography
                  variant="body2"
                  component="span"
                  sx={{ color: "text.secondary", ml: 0.5, fontSize: 13, fontStyle: "italic" }}
                >
                  by InteractionCoder
                </Typography>
              </Box>
              <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                <FormControlLabel
                  control={<Switch checked={autoPaste} onChange={toggleAutoPaste} size="small" />}
                  label="Auto-paste"
                  sx={{ mr: 0, "& .MuiFormControlLabel-label": { fontSize: 14 } }}
                />
                <Tooltip title={darkMode ? "Switch to light mode" : "Switch to dark mode"}>
                  <IconButton onClick={toggleDarkMode} color="inherit">
                    <Icon>{darkMode ? "light_mode" : "dark_mode"}</Icon>
                  </IconButton>
                </Tooltip>
              </Box>
            </Box>
            <Container maxWidth={false} sx={{ mt: 10, width: "80%" }}>
              <Box display="flex" flexDirection="column" alignItems="center" gap={3}>
                <Button
                  variant="contained"
                  size="large"
                  startIcon={<Icon>content_paste</Icon>}
                  onClick={handlePaste}
                  disabled={loading}
                  sx={{ fontSize: 24, py: 2, px: 4 }}
                >
                  PASTE
                </Button>
                <Box sx={{ width: "100%" }}>
                  <Paper
                    elevation={3}
                    sx={{
                      width: "100%",
                      minHeight: 120,
                      p: 3,
                      bgcolor: "background.paper",
                      whiteSpace: "pre-wrap",
                      wordBreak: "break-word",
                      fontFamily: "'Roboto Mono', monospace",
                      fontSize: 14,
                      maxHeight: "60vh",
                      overflowY: "auto",
                    }}
                  >
                    {renderContent()}
                  </Paper>
                  <Box sx={{ display: "flex", justifyContent: "flex-end", gap: 1, mt: 1.5 }}>
                    <Tooltip title="Clear clipboard">
                      <span>
                        <Button
                          variant="contained"
                          color="error"
                          size="small"
                          startIcon={<Icon>delete_outline</Icon>}
                          onClick={handleClear}
                          disabled={!content}
                          aria-label="clear"
                          sx={{ fontSize: 12, py: 1, px: 2 }}
                        >
                          CLEAR
                        </Button>
                      </span>
                    </Tooltip>
                    <Tooltip title="Copy to clipboard">
                      <span>
                        <Button
                          variant="contained"
                          color={justCopied ? "success" : "primary"}
                          size="small"
                          startIcon={<Icon>{justCopied ? "check" : "content_copy"}</Icon>}
                          onClick={handleCopy}
                          disabled={!content}
                          aria-label="copy"
                          sx={{ fontSize: 12, py: 1, px: 2 }}
                        >
                          {justCopied ? "COPIED!" : "COPY"}
                        </Button>
                      </span>
                    </Tooltip>
                  </Box>
                  {updatedAt && (
                    <Typography variant="caption" color="text.secondary" sx={{ mt: 0.5, display: "block", textAlign: "right" }}>
                      Last synced: {timeAgo}
                    </Typography>
                  )}
                </Box>
              </Box>
            </Container>
            <Snackbar
              open={snackbar.open}
              autoHideDuration={3000}
              onClose={() => setSnackbar(s => ({ ...s, open: false }))}
              anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
            >
              <Alert
                onClose={() => setSnackbar(s => ({ ...s, open: false }))}
                severity={snackbar.severity}
                sx={{ width: "100%" }}
              >
                {snackbar.message}
              </Alert>
            </Snackbar>
          </ThemeProvider>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(
        <ErrorBoundary><App /></ErrorBoundary>
      );
    </script>
  </body>
</html>
